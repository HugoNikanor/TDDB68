diff --git a/linuxpintos/src/filesys/filesys.c b/linuxpintos/src/filesys/filesys.c
index fedda08..dd42fd0 100644
--- a/linuxpintos/src/filesys/filesys.c
+++ b/linuxpintos/src/filesys/filesys.c
@@ -87,7 +87,7 @@ filesys_remove (const char *name)
   struct dir *dir = dir_open_root ();
   bool success = dir != NULL && dir_remove (dir, name);
   dir_close (dir); 
-
+  
   return success;
 }
 
diff --git a/linuxpintos/src/filesys/inode.c b/linuxpintos/src/filesys/inode.c
index cfdcb7b..001a44b 100644
--- a/linuxpintos/src/filesys/inode.c
+++ b/linuxpintos/src/filesys/inode.c
@@ -6,6 +6,7 @@
 #include "filesys/filesys.h"
 #include "filesys/free-map.h"
 #include "threads/malloc.h"
+#include "threads/synch.h"
 
 /* Identifies an inode. */
 #define INODE_MAGIC 0x494e4f44
@@ -37,6 +38,11 @@ struct inode
     bool removed;                       /* True if deleted, false otherwise. */
     int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
     struct inode_disk data;             /* Inode content. */
+
+    int readcount; //Currently reading from inode
+    struct semaphore wsem; //Semaphore for writers
+    struct semaphore rsem; //Semaphore for readers
+    struct lock mut_lock; //Is mutating this node.
   };
 
 /* Returns the disk sector that contains byte offset POS within
@@ -99,6 +105,10 @@ inode_create (disk_sector_t sector, off_t length)
                 disk_write (filesys_disk, disk_inode->start + i, zeros); 
             }
           success = true; 
+	  struct inode *new_inode = inode_open(disk_inode->start);
+	  sema_init(&new_inode->wsem, 1); //Inits locks and semas for filesys. 
+	  sema_init(&new_inode->rsem, 1); //
+	  lock_acquire(&new_inode->mut_lock); // 
         } 
       free (disk_inode);
     }
@@ -127,7 +137,7 @@ inode_open (disk_sector_t sector)
     }
 
   /* Allocate memory. */
-  inode = malloc (sizeof *inode);
+  inode = malloc(sizeof *inode);
   if (inode == NULL)
     return NULL;
 
@@ -207,6 +217,14 @@ inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset)
   off_t bytes_read = 0;
   uint8_t *bounce = NULL;
 
+  //Synchronization
+  sema_down(&inode->rsem);
+  inode->readcount++;
+  if(inode->readcount == 1){
+    sema_down(&inode->wsem);
+  }
+  sema_up(&inode->rsem);
+
   while (size > 0) 
     {
       /* Disk sector to read, starting byte offset within sector. */
@@ -249,6 +267,14 @@ inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset)
     }
   free (bounce);
 
+  //Done reading, more synchronization
+  sema_down(&inode->rsem);
+  inode->readcount--;
+  if(inode->readcount == 0){
+    sema_up(&inode->wsem);
+  }
+  sema_up(&inode->rsem);
+
   return bytes_read;
 }
 
@@ -265,8 +291,14 @@ inode_write_at (struct inode *inode, const void *buffer_, off_t size,
   off_t bytes_written = 0;
   uint8_t *bounce = NULL;
 
+  //Synchronization
+  sema_down(&inode->wsem);
+
+  //Old and bad??
+  /* 
   if (inode->deny_write_cnt)
     return 0;
+  */
 
   while (size > 0) 
     {
@@ -317,6 +349,9 @@ inode_write_at (struct inode *inode, const void *buffer_, off_t size,
     }
   free (bounce);
 
+  //Synchronization, done writing
+  sema_up(&inode->wsem); 
+
   return bytes_written;
 }
 
diff --git a/linuxpintos/src/userprog/syscall.c b/linuxpintos/src/userprog/syscall.c
index f726d1f..f285aef 100644
--- a/linuxpintos/src/userprog/syscall.c
+++ b/linuxpintos/src/userprog/syscall.c
@@ -80,6 +80,28 @@ syscall_handler (struct intr_frame *f UNUSED)
       f->eax = wait(pid);
       break;
     }
+    case SYS_SEEK:{
+      int fd_seek = *((int*)(sp));
+      update_sp(&sp);
+      unsigned pos = *((unsigned*)(sp));
+      seek(fd_seek, pos); 
+      break; 
+    }
+    case SYS_TELL:{
+      int fd_tell = *((int*)(sp));
+      f->eax = tell(fd_tell);
+      break; 
+    }
+    case SYS_FILESIZE:{
+      int fd_size = *((int*)(sp));
+      f->eax = filesize(fd_size);
+      break;
+    } 
+    case SYS_REMOVE:{
+      char *filename = *((char**)(sp));
+      f->eax = remove(filename); 
+      break; 
+    }
   }
 }
 
@@ -289,3 +311,49 @@ int wait(tid_t pid){
   return process_wait(pid);
 }
 
+void
+seek(int fd, unsigned position) {
+  if(fd <= 1 || fd >= 130){
+    exit(-1);
+  }
+
+  struct thread *cur_thread = thread_current();
+  struct file *seek_file = cur_thread->file_list[fd-2];
+
+  file_seek(seek_file, position);
+}
+
+unsigned
+tell(int fd){
+  if(fd <= 1 || fd >= 130){
+    exit(-1);
+  }
+
+  struct thread *cur_thread = thread_current();
+  struct file *tell_file = cur_thread->file_list[fd-2];
+
+  file_tell(tell_file);
+}
+
+int 
+filesize(int fd){
+  if(fd <= 1 || fd >= 130){
+    exit(-1);
+  }
+
+  struct thread *cur_thread = thread_current();
+  struct file *size_file = cur_thread->file_list[fd-2];
+
+  file_length(size_file);
+}
+
+bool
+remove (const char *file_name){
+  if(!is_valid_string(file_name)){
+    exit(-1);
+  }
+
+  filesys_remove(file_name);
+}
+
+
diff --git a/linuxpintos/src/userprog/syscall.h b/linuxpintos/src/userprog/syscall.h
index 4e1d7bc..0f07583 100644
--- a/linuxpintos/src/userprog/syscall.h
+++ b/linuxpintos/src/userprog/syscall.h
@@ -17,5 +17,8 @@ int write(int fd, void *buffer, unsigned size);
 void exit(int status);
 tid_t exec(const char *cmd_line);
 int wait(tid_t pid);
-void assert_list_init();
+void seek(int fd, unsigned position);
+unsigned tell(int fd);
+int filesize(int fd);
+bool remove (const char *file_name);
 #endif /* userprog/syscall.h */
